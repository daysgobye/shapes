{"version":3,"sources":["componets/svgRender.js","helpers.js/placement.js","componets/canvas.js","classes/shape.js","componets/uploadShape.js","componets/editShape.js","componets/notes.js","componets/shapes.js","componets/home.js","App.js","serviceWorker.js","index.js"],"names":["SvgRender","props","handleLoad","setState","image","state","this","loadImage","oldProps","src","removeEventListener","window","Image","addEventListener","key","x","y","scaleX","scale","scaleY","width","height","ref","node","imageNode","Component","placeInZone","cap","randomInRange","min","max","Math","floor","random","Canvas","posAllShapes","savedRender","shapes","textFile","makeTextFile","text","data","Blob","type","URL","revokeObjectURL","createObjectURL","saveFile","downloadURI","JSON","stringify","uri","name","link","document","createElement","download","href","body","appendChild","click","removeChild","saveImage","dataURL","stageRef","current","getStage","toDataURL","pixelRatio","renderArrayOfShapes","shape","array","loopShape","count","console","log","length","numToRender","innerWidth","sideBar","innerHeight","noIn","otherBodys","i","flat","pos","push","minSize","shapeRender","map","React","createRef","fill","style","display","flexDirection","onClick","id","imgName","toObj","color","maxSize","setPos","upDateNum","num","Number","upDateMinSize","imageName","UploadShape","makeShape","e","Shape","target","files","addShape","fileRef","onChange","EditShape","onUpdateScale","updateShape","scaleRef","value","onUpdateAmount","amountToSpawnRef","alt","Notes","Shapes","Home","s","App","className","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"2TAwDeA,E,YApDb,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAsBRC,WAAa,WAGX,EAAKC,SAAS,CACZC,MAAO,EAAKA,SAzBd,EAAKC,MAAQ,CACXD,MAAO,MAHQ,E,iFAOjBE,KAAKC,c,yCAEYC,GACbA,EAASC,MAAQH,KAAKL,MAAMQ,KAC9BH,KAAKC,c,6CAIPD,KAAKF,MAAMM,oBAAoB,OAAQJ,KAAKJ,c,kCAI5CI,KAAKF,MAAQ,IAAIO,OAAOC,MACxBN,KAAKF,MAAMK,IAAMH,KAAKL,MAAMQ,IAC5BH,KAAKF,MAAMS,iBAAiB,OAAQP,KAAKJ,c,+BAYjC,IAAD,OACP,OACE,kBAAC,QAAD,CACEY,IAAKR,KAAKL,MAAMa,IAChBC,EAAGT,KAAKL,MAAMc,EACdC,EAAGV,KAAKL,MAAMe,EACdC,OAAQX,KAAKL,MAAMiB,MACnBC,OAAQb,KAAKL,MAAMiB,MACnBd,MAAOE,KAAKD,MAAMD,MAClBgB,MAAO,IACPC,OAAQ,IACRC,IAAK,SAAAC,GACH,EAAKC,UAAYD,S,GA9CHE,aCKXC,EAAc,SAAAC,GAAG,OAAIC,EAAc,GAAID,EAAM,MAE7CC,EAAgB,SAACC,EAAKC,GAAN,OAC3BC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,GAAKA,ICmKhCK,E,YAjKb,WAAYjC,GAAQ,IAAD,8BACjB,4CAAMA,KAIRkC,aAAe,WACb,EAAKC,YAAc,GACnB,EAAKjC,SACH,CACEkC,OAAQ,EAAKpC,MAAMoC,SAErB,gBAXe,EAiBnBD,YAAc,GAjBK,EAkBnBE,SAAW,KAlBQ,EAoBnBC,aAAe,SAAAC,GACb,IAAIC,EAAO,IAAIC,KAAK,CAACF,GAAO,CAAEG,KAAM,eAWpC,OAPsB,OAAlB,EAAKL,UACP3B,OAAOiC,IAAIC,gBAAgB,EAAKP,UAGlC,EAAKA,SAAW3B,OAAOiC,IAAIE,gBAAgBL,GAGpC,EAAKH,UAhCK,EAmCnBS,SAAW,WAmBT,EAAKC,YACH,EAAKT,aAAaU,KAAKC,UAAU,EAAKd,cACtC,gBAxDe,EA2DnBY,YAAc,SAACG,EAAKC,GAClB,IAAIC,EAAOC,SAASC,cAAc,KAClCF,EAAKG,SAAWJ,EAChBC,EAAKI,KAAON,EACZG,SAASI,KAAKC,YAAYN,GAC1BA,EAAKO,QACLN,SAASI,KAAKG,YAAYR,IAjET,EAmEnBS,UAAY,WACV,IAAMC,EAAU,EAAKC,SAASC,QAC3BC,WACAC,UAAU,CAAEC,WAAY,IAC3B,EAAKpB,YAAYe,EAAS,cAvET,EA0EnBM,oBAAsB,SAAAC,GACpB,IAAIC,EAAQ,GACRC,EAAY,GACZC,EAAQ,EAGZ,IAFAC,QAAQC,IAAIL,EAAO,0BAEZE,EAAUI,OAASN,EAAMO,aAAeJ,EAAQ,KAAM,CAO3D,IANA,IAAI1D,EAAIW,EAAYf,OAAOmE,WAAa,EAAKzE,MAAM0E,SAC/C/D,EAAIU,EAAYf,OAAOqE,aACvBC,GAAO,EAGPC,GAFkBZ,EAAMpD,MAEd,UAAOsD,EAAP,YAAqB,EAAKpC,eAC/B+C,EAAI,EAAGA,EAAID,EAAWE,OAAOR,OAAQO,IAAK,CACjD,IAAME,EAAMH,EAAWE,OAAOD,GAE5BE,EAAIA,KACJtE,EAAIsE,EAAIA,IAAItE,EAAI,KAChBA,EAAIsE,EAAIA,IAAItE,EAAI,KAChBC,EAAIqE,EAAIA,IAAIrE,EAAI,KAChBA,EAAIqE,EAAIA,IAAIrE,EAAI,MAEhB0D,QAAQC,IAAI,WACZM,GAAO,EACPR,KAIAQ,IACFV,EAAMe,KACJ,kBAAC,EAAD,CACExE,IAAG,aAAQyD,EAAMK,OAAS5D,EAAID,GAC9BN,IAAK6D,EAAMlE,MACXW,EAAGA,EACHC,EAAGA,EACHE,MAAOoD,EAAMiB,WAGjBf,EAAUc,KAAV,eAAoBhB,EAApB,CAA2Be,IAAK,CAAEtE,IAAGC,SAIzC,OADA,EAAKoB,YAAYkD,KAAKd,GACfD,GApHU,EAuHnBiB,YAAc,WAKZ,OAJe,EAAKnF,MAAMgC,OAAOoD,KAAI,SAAAnB,GACnC,OAAO,EAAKD,oBAAoBC,OAvHlC,EAAKjE,MAAQ,CAAEgC,OAAQ,GAAI0C,QAAS,KACpC,EAAKf,SAAW0B,IAAMC,YAHL,E,sEAgIjB,OACE,oCACE,kBAAC,QAAD,CACErE,IAAKhB,KAAK0D,SACV5C,MAAOT,OAAOmE,WAAaxE,KAAKD,MAAM0E,QACtC1D,OAAQV,OAAOqE,aAEf,kBAAC,QAAD,KACE,kBAAC,OAAD,CACEjE,EAAG,EACHC,EAAG,EACHI,MAAOT,OAAOmE,WAAaxE,KAAKD,MAAM0E,QACtC1D,OAAQV,OAAOqE,YACfY,KAAK,WAGT,kBAAC,QAAD,KACGtF,KAAKkF,gBAIV,yBAAKK,MAAO,CAAEC,QAAS,OAAQC,cAAe,WAC5C,4BAAQC,QAAS1F,KAAK6B,cAAtB,OACA,4BAAQ6D,QAAS1F,KAAKwD,WAAtB,cACA,4BAAQkC,QAAS1F,KAAKyC,UAAtB,aAGF,yBAAKkD,GAAG,gB,GA5JKxE,aCmBN6C,EA9Bb,WAAYlE,EAAO8F,GAAU,IAAD,gCAS5BC,MAAQ,WACN,MAAO,CACL/F,MAAO,EAAKA,MACZiF,IAAK,EAAKA,IACVe,MAAO,EAAKA,MACZb,QAAS,EAAKA,QACdc,QAAS,EAAKA,UAfU,KAkB5BC,OAAS,SAAAjB,GACP,EAAKA,IAAMA,GAnBe,KAqB5BkB,UAAY,SAAAC,GAEV,OADA,EAAK3B,YAAc4B,OAAOD,GACnB,GAvBmB,KAyB5BE,cAAgB,SAAAF,GAEd,OADA,EAAKjB,QAAUkB,OAAOD,GACf,GA1BPlG,KAAKF,MAAQA,EACbE,KAAKqG,UAAYT,EACjB5F,KAAK+E,IAAM,CAAEtE,EAAG,EAAGC,EAAG,GACtBV,KAAK8F,MAAQ,SACb9F,KAAKiF,QAAU,EACfjF,KAAK+F,QAAU,EACf/F,KAAKuE,YAAc,GCoBR+B,E,YAzBb,WAAY3G,GAAQ,IAAD,8BACjB,4CAAMA,KAIR4G,UAAY,SAAAC,GAEV,IAAMxC,EAAQ,IAAIyC,EAChBnE,IAAIE,gBAAgBgE,EAAEE,OAAOC,MAAM,IACnCH,EAAEE,OAAOC,MAAM,GAAG7D,MAEpBsB,QAAQC,IAAIL,EAAO,OAAQwC,EAAEE,OAAOC,MAAM,IAE1C,EAAKhH,MAAMiH,SAAS5C,IAXpB,EAAKjE,MAAQ,GACb,EAAK8G,QAAUzB,IAAMC,YAHJ,E,sEAeT,IAAD,OACP,OACE,6BACE,2BAAOhD,KAAK,OAAOS,KAAK,GAAG6C,GAAG,GAAGmB,SAAU,SAAAN,GAAC,OAAI,EAAKD,UAAUC,MAC/D,4BAAQd,QAAS1F,KAAKuG,WAAtB,Y,GApBkBpF,aC+CX4F,E,YA9Cb,WAAYpH,GAAQ,IAAD,8BACjB,4CAAMA,KAKRqH,cAAgB,WACd,EAAKrH,MAAMsH,YACT,EAAKtH,MAAMqE,MAAMoC,cAAc,EAAKc,SAASvD,QAAQwD,SARtC,EAWnBC,eAAiB,WACf,EAAKzH,MAAMsH,YACT,EAAKtH,MAAMqE,MAAMiC,UAAU,EAAKoB,iBAAiB1D,QAAQwD,SAX3D,EAAKpH,MAAQ,GACb,EAAKsH,iBAAmBjC,IAAMC,YAC9B,EAAK6B,SAAW9B,IAAMC,YAJL,E,sEAgBT,IACArB,EAAUhE,KAAKL,MAAfqE,MACR,OACE,yBAAKxD,IAAKR,KAAKL,MAAMa,KAGnB,kDAEE,2BACEsG,SAAU9G,KAAKoH,eACfpG,IAAKhB,KAAKqH,iBACVhF,KAAK,OACL8E,MAAOnD,EAAMO,eAYjB,yBAAKpE,IAAK6D,EAAMlE,MAAOgB,MAAO,IAAKC,OAAQ,IAAKuG,IAAI,U,GAzCpCnG,aCmBToG,E,YAnBb,WAAY5H,GAAQ,IAAD,8BACjB,4CAAMA,KACDI,MAAQ,GAFI,E,sEAKjB,OACE,6BACE,uEACA,oFAEE,6BAFF,0EAIE,6BAJF,sE,GATYoB,aC0BLqG,E,YAtBb,WAAY7H,GAAQ,IAAD,8BACjB,4CAAMA,KACDI,MAAQ,GAFI,E,sEAKT,IAAD,OACP,OACE,6BACGC,KAAKL,MAAMoC,OAAOoD,KAAI,SAACnB,EAAOa,GAAR,OACrB,kBAAC,EAAD,CACEoC,YAAa,EAAKtH,MAAMsH,YACxBjD,MAAOA,EACPxD,IAAKqE,OAGT,kBAAC,EAAD,CAAa+B,SAAU5G,KAAKL,MAAMiH,WAClC,kBAAC,EAAD,W,GAjBazF,aCmCNsG,E,YAlCb,WAAY9H,GAAQ,IAAD,8BACjB,4CAAMA,KAKRiH,SAAW,SAAA5C,GACT,IAAMjC,EAAM,CAAIiC,GAAJ,mBAAc,EAAKjE,MAAMgC,SACrC,EAAKlC,SAAS,CAAEkC,YARC,EAUnBkF,YAAc,SAAAjD,GACZ,IAAMjC,EAAS,EAAKhC,MAAMgC,OAAOoD,KAAI,SAAAuC,GAAC,OACpCA,EAAE5H,QAAUkE,EAAMlE,MAAQkE,EAAQ0D,KAEpC,EAAK7H,SAAS,CAAEkC,YAZhB,EAAKhC,MAAQ,CACXgC,OAAQ,IAHO,E,sEAiBjB,OACE,yBAAKwD,MAAO,CAAEC,QAAS,SACrB,yBAAKD,MAAO,CAAEC,QAAS,SACrB,kBAAC,EAAD,CAAQzD,OAAQ/B,KAAKD,MAAMgC,UAE7B,yBAAKwD,MAAO,CAAEC,QAAS,SACrB,kBAAC,EAAD,CACEzD,OAAQ/B,KAAKD,MAAMgC,OACnB6E,SAAU5G,KAAK4G,SACfK,YAAajH,KAAKiH,oB,GA3BX9F,aCSJwG,MARf,WACE,OACE,yBAAKC,UAAU,OACb,kBAAC,EAAD,QCIcC,QACW,cAA7BxH,OAAOyH,SAASC,UAEe,UAA7B1H,OAAOyH,SAASC,UAEhB1H,OAAOyH,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASlF,SAASmF,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.fb9e0360.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Stage, Layer, Image } from \"react-konva\";\n// import useImage from 'use-image';\nclass SvgRender extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      image: null\n    };\n  }\n  componentDidMount() {\n    this.loadImage();\n  }\n  componentDidUpdate(oldProps) {\n    if (oldProps.src !== this.props.src) {\n      this.loadImage();\n    }\n  }\n  componentWillUnmount() {\n    this.image.removeEventListener(\"load\", this.handleLoad);\n  }\n  loadImage() {\n    // save to \"this\" to remove \"load\" handler on unmount\n    this.image = new window.Image();\n    this.image.src = this.props.src;\n    this.image.addEventListener(\"load\", this.handleLoad);\n  }\n  handleLoad = () => {\n    // after setState react-konva will update canvas and redraw the layer\n    // because \"image\" property is changed\n    this.setState({\n      image: this.image\n    });\n    // if you keep same image object during source updates\n    // you will have to update layer manually:\n    // this.imageNode.getLayer().batchDraw();\n  };\n  render() {\n    return (\n      <Image\n        key={this.props.key}\n        x={this.props.x}\n        y={this.props.y}\n        scaleX={this.props.scale}\n        scaleY={this.props.scale}\n        image={this.state.image}\n        width={100}\n        height={100}\n        ref={node => {\n          this.imageNode = node;\n        }}\n      />\n    );\n  }\n}\n\nexport default SvgRender;\n\n// import React, { Component } from 'react';\n// import { render } from 'react-dom';\n// import { Stage, Layer, Image } from 'react-konva';\n// import useImage from 'use-image';\n\n// // custom component that will handle loading image from url\n// // you may add more logic here to handle \"loading\" state\n// // or if loading is failed\n// // VERY IMPORTANT NOTES:\n// // at first we will set image state to null\n// // and then we will set it to native image instance when it is loaded\n// class URLImage extends React.Component {\n//   state = {\n//     image: null\n//   };\n//   componentDidMount() {\n//     this.loadImage();\n//   }\n//   componentDidUpdate(oldProps) {\n//     if (oldProps.src !== this.props.src) {\n//       this.loadImage();\n//     }\n//   }\n//   componentWillUnmount() {\n//     this.image.removeEventListener('load', this.handleLoad);\n//   }\n//   loadImage() {\n//     // save to \"this\" to remove \"load\" handler on unmount\n//     this.image = new window.Image();\n//     this.image.src = this.props.src;\n//     this.image.addEventListener('load', this.handleLoad);\n//   }\n//   handleLoad = () => {\n//     // after setState react-konva will update canvas and redraw the layer\n//     // because \"image\" property is changed\n//     this.setState({\n//       image: this.image\n//     });\n//     // if you keep same image object during source updates\n//     // you will have to update layer manually:\n//     // this.imageNode.getLayer().batchDraw();\n//   };\n//   render() {\n//     return (\n//       <Image\n//         x={this.props.x}\n//         y={this.props.y}\n//         image={this.state.image}\n//         ref={node => {\n//           this.imageNode = node;\n//         }}\n//       />\n//     );\n//   }\n// }\n","export const placement = (shapes, width, height) => {\n  return shapes.map(shape => {\n    return {\n      ...shape,\n      pos: { x: randomInRange(1, width), y: randomInRange(1, height) }\n    };\n  });\n};\nexport const placeInZone = cap => randomInRange(10, cap - 100);\n\nexport const randomInRange = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1) + min);\n\nexport const placementInter = (cap, otherBodys, count = 1) => {\n  let newPos = {\n    x: randomInRange(100, cap.innerWidth - 700),\n    y: randomInRange(100, cap.innerHeight - 100)\n  };\n\n  for (let i = 0; i < otherBodys.flat().length; i++) {\n    const pos = otherBodys.flat()[i];\n    if (\n      newPos.x > pos.pos.x &&\n      newPos.x < pos.pos.x + 120 &&\n      newPos.y > pos.pos.y &&\n      newPos.y < pos.pos.y + 120\n    ) {\n      console.log(\"I got fucked\");\n      if (count < 10) {\n        placementInter(cap, otherBodys, count + 1);\n      } else {\n        console.log(\"offset\");\n\n        newPos = {\n          x: -100,\n          y: -100\n        };\n      }\n    }\n  }\n  console.log(newPos.x);\n\n  return newPos;\n};\n","import React, { Component } from \"react\";\nimport Canvg from \"canvg\";\n// import logo from \"./logo.svg\";\n// import icon from \"../ic.svg\";\nimport Konva from \"konva\";\nimport { Stage, Layer, Image, Rect } from \"react-konva\";\nimport SvgRender from \"./svgRender\";\nimport {\n  placement,\n  placeInZone,\n  placementInter\n} from \"../helpers.js/placement\";\nclass Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { shapes: [], sideBar: 600 };\n    this.stageRef = React.createRef();\n  }\n  posAllShapes = () => {\n    this.savedRender = [];\n    this.setState(\n      {\n        shapes: this.props.shapes\n      },\n      () => {\n        // this.saveFile();\n        // this.saveImage();\n      }\n    );\n  };\n  savedRender = [];\n  textFile = null;\n\n  makeTextFile = text => {\n    var data = new Blob([text], { type: \"text/plain\" });\n\n    // If we are replacing a previously generated file we need to\n    // manually revoke the object URL to avoid memory leaks.\n    if (this.textFile !== null) {\n      window.URL.revokeObjectURL(this.textFile);\n    }\n\n    this.textFile = window.URL.createObjectURL(data);\n\n    // returns a URL you can use as a href\n    return this.textFile;\n  };\n\n  saveFile = () => {\n    // var create = document.getElementById(\"create\");\n    // create.addEventListener(\n    //   \"click\",\n    //   function() {\n    //     var link = document.createElement(\"a\");\n    //     link.setAttribute(\"download\", \"shapes.txt\");\n    //     link.href = this.makeTextFile(JSON.stringify(this.state.shapes));\n    //     document.body.appendChild(link);\n\n    //     // wait for the link to be added to the document\n    //     window.requestAnimationFrame(function() {\n    //       var event = new MouseEvent(\"click\");\n    //       link.dispatchEvent(event);\n    //       document.body.removeChild(link);\n    //     });\n    //   },\n    //   false\n    // );\n    this.downloadURI(\n      this.makeTextFile(JSON.stringify(this.savedRender)),\n      \"shapes.json\"\n    );\n  };\n  downloadURI = (uri, name) => {\n    var link = document.createElement(\"a\");\n    link.download = name;\n    link.href = uri;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n  saveImage = () => {\n    const dataURL = this.stageRef.current\n      .getStage()\n      .toDataURL({ pixelRatio: 3 });\n    this.downloadURI(dataURL, \"stage.png\");\n  };\n\n  renderArrayOfShapes = shape => {\n    let array = [];\n    let loopShape = [];\n    let count = 0;\n    console.log(shape, \"I need this shape flag\");\n\n    while (loopShape.length < shape.numToRender && count < 1000) {\n      let x = placeInZone(window.innerWidth - this.state.sideBar);\n      let y = placeInZone(window.innerHeight);\n      let noIn = true;\n      const overlap = 100 * shape.scale;\n      // let pos=placementInter( window,[...this.savedRender,...loopShape] )\n      let otherBodys = [...loopShape, ...this.savedRender];\n      for (let i = 0; i < otherBodys.flat().length; i++) {\n        const pos = otherBodys.flat()[i];\n        if (\n          pos.pos &&\n          x > pos.pos.x - 100 &&\n          x < pos.pos.x + 100 &&\n          y > pos.pos.y - 100 &&\n          y < pos.pos.y + 100\n        ) {\n          console.log(\"overlap\");\n          noIn = false;\n          count++;\n        }\n        // console.log(pos.pos, \"pos\");\n      }\n      if (noIn) {\n        array.push(\n          <SvgRender\n            key={`img${array.length * y * x}`}\n            src={shape.image}\n            x={x}\n            y={y}\n            scale={shape.minSize}\n          />\n        );\n        loopShape.push({ ...shape, pos: { x, y } });\n      }\n    }\n    this.savedRender.push(loopShape);\n    return array;\n  };\n\n  shapeRender = () => {\n    const render = this.state.shapes.map(shape => {\n      return this.renderArrayOfShapes(shape);\n    });\n    // this.savedRender = render;\n    return render;\n  };\n\n  render() {\n    return (\n      <>\n        <Stage\n          ref={this.stageRef}\n          width={window.innerWidth - this.state.sideBar}\n          height={window.innerHeight}\n        >\n          <Layer>\n            <Rect\n              x={0}\n              y={0}\n              width={window.innerWidth - this.state.sideBar}\n              height={window.innerHeight}\n              fill=\"white\"\n            />\n          </Layer>\n          <Layer>\n            {this.shapeRender()}\n            {/* <SvgRender src={icon} x={300} y={800} scale={8} /> */}\n          </Layer>\n        </Stage>\n        <div style={{ display: \"flex\", flexDirection: \"column\" }}>\n          <button onClick={this.posAllShapes}>mix</button>\n          <button onClick={this.saveImage}>Save Image</button>\n          <button onClick={this.saveFile}>Save set</button>\n        </div>\n\n        <div id=\"create\"></div>\n      </>\n    );\n  }\n}\n\nexport default Canvas;\n","class shape {\n  constructor(image, imgName) {\n    this.image = image;\n    this.imageName = imgName;\n    this.pos = { x: 1, y: 1 };\n    this.color = \"#fffff\";\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.numToRender = 1;\n  }\n  toObj = () => {\n    return {\n      image: this.image,\n      pos: this.pos,\n      color: this.color,\n      minSize: this.minSize,\n      maxSize: this.maxSize\n    };\n  };\n  setPos = pos => {\n    this.pos = pos;\n  };\n  upDateNum = num => {\n    this.numToRender = Number(num);\n    return this;\n  };\n  upDateMinSize = num => {\n    this.minSize = Number(num);\n    return this;\n  };\n}\nexport default shape;\n","import React, { Component } from \"react\";\nimport Shape from \"../classes/shape\";\nclass UploadShape extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.fileRef = React.createRef();\n  }\n  makeShape = e => {\n    // console.log(shape, \"file\", e.target.files[0]);\n    const shape = new Shape(\n      URL.createObjectURL(e.target.files[0]),\n      e.target.files[0].name\n    );\n    console.log(shape, \"file\", e.target.files[0]);\n\n    this.props.addShape(shape);\n  };\n  render() {\n    return (\n      <div>\n        <input type=\"file\" name=\"\" id=\"\" onChange={e => this.makeShape(e)} />\n        <button onClick={this.makeShape}>go </button>\n      </div>\n    );\n  }\n}\n\nexport default UploadShape;\n","import React, { Component } from \"react\";\nimport shape from \"../classes/shape\";\nclass EditShape extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.amountToSpawnRef = React.createRef();\n    this.scaleRef = React.createRef();\n  }\n  onUpdateScale = () => {\n    this.props.updateShape(\n      this.props.shape.upDateMinSize(this.scaleRef.current.value)\n    );\n  };\n  onUpdateAmount = () => {\n    this.props.updateShape(\n      this.props.shape.upDateNum(this.amountToSpawnRef.current.value)\n    );\n  };\n  render() {\n    const { shape } = this.props;\n    return (\n      <div key={this.props.key}>\n        {/* {shape.color} */}\n        {/* {shape.image} */}\n        <label>\n          number to spawn:\n          <input\n            onChange={this.onUpdateAmount}\n            ref={this.amountToSpawnRef}\n            type=\"text\"\n            value={shape.numToRender}\n          />\n        </label>\n        {/* <label>\n          scale:\n          <input\n            ref={this.scaleRef}\n            onChange={this.onUpdateScale}\n            type=\"text\"\n            value={shape.minSize}\n          />\n        </label> */}\n        <img src={shape.image} width={100} height={100} alt=\"\" />\n      </div>\n    );\n  }\n}\n\nexport default EditShape;\n","import React, { Component } from \"react\";\nclass Notes extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n  render() {\n    return (\n      <div>\n        <h5>some things are missing / not ready yet</h5>\n        <p>\n          color, random scale, overlap control's, phone support,\n          <br /> locked down to just svgs(you can upload any image you want\n          right now),\n          <br /> replay from saved files, some svgs are broken, exporting svg\n        </p>\n      </div>\n    );\n  }\n}\n\nexport default Notes;\n","import React, { Component } from \"react\";\nimport UploadShape from \"./uploadShape\";\nimport EditShape from \"./editShape\";\nimport Notes from \"./notes\";\nclass Shapes extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    return (\n      <div>\n        {this.props.shapes.map((shape, i) => (\n          <EditShape\n            updateShape={this.props.updateShape}\n            shape={shape}\n            key={i}\n          ></EditShape>\n        ))}\n        <UploadShape addShape={this.props.addShape}></UploadShape>\n        <Notes></Notes>\n      </div>\n    );\n  }\n}\n\nexport default Shapes;\n","import React, { Component } from \"react\";\nimport { Grid, box } from \"@material-ui/core\";\nimport Canvas from \"./canvas\";\nimport Shapes from \"./shapes\";\nclass Home extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      shapes: []\n    };\n  }\n  addShape = shape => {\n    const shapes = [shape, ...this.state.shapes];\n    this.setState({ shapes });\n  };\n  updateShape = shape => {\n    const shapes = this.state.shapes.map(s =>\n      s.image === shape.image ? shape : s\n    );\n    this.setState({ shapes });\n  };\n  render() {\n    return (\n      <div style={{ display: \"flex\" }}>\n        <div style={{ display: \"flex\" }}>\n          <Canvas shapes={this.state.shapes}></Canvas>\n        </div>\n        <div style={{ display: \"flex\" }}>\n          <Shapes\n            shapes={this.state.shapes}\n            addShape={this.addShape}\n            updateShape={this.updateShape}\n          ></Shapes>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","import React from \"react\";\n// import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Home from \"./componets/home\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Home></Home>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}