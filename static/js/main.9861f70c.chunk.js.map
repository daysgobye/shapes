{"version":3,"sources":["componets/svgRender.js","helpers.js/placement.js","componets/canvas.js","classes/shape.js","componets/uploadShape.js","componets/editShape.js","componets/notes.js","componets/shapes.js","componets/home.js","App.js","serviceWorker.js","index.js"],"names":["SvgRender","props","handleLoad","setState","image","state","this","loadImage","oldProps","src","removeEventListener","window","Image","addEventListener","key","x","y","scaleX","scale","scaleY","width","height","ref","node","imageNode","Component","placement","shapes","map","shape","pos","randomInRange","placeInZone","cap","min","max","Math","floor","random","Canvas","posAllShapes","savedRender","innerWidth","innerHeight","textFile","makeTextFile","text","data","Blob","type","URL","revokeObjectURL","createObjectURL","saveFile","downloadURI","JSON","stringify","uri","name","link","document","createElement","download","href","body","appendChild","click","removeChild","saveImage","dataURL","stageRef","current","getStage","toDataURL","pixelRatio","renderArrayOfShapes","array","loopShape","count","length","numToRender","sideBar","noIn","otherBodys","i","flat","console","log","push","minSize","shapeRender","React","createRef","fill","style","display","flexDirection","onClick","id","imgName","toObj","color","maxSize","setPos","upDateNum","num","Number","upDateMinSize","imageName","UploadShape","makeShape","e","Shape","target","files","addShape","fileRef","onChange","EditShape","onUpdateScale","updateShape","scaleRef","value","onUpdateAmount","amountToSpawnRef","alt","Notes","Shapes","Home","s","App","className","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9861f70c.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport { Stage, Layer, Image } from \"react-konva\";\n// import useImage from 'use-image';\nclass SvgRender extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      image: null\n    };\n  }\n  componentDidMount() {\n    this.loadImage();\n  }\n  componentDidUpdate(oldProps) {\n    if (oldProps.src !== this.props.src) {\n      this.loadImage();\n    }\n  }\n  componentWillUnmount() {\n    this.image.removeEventListener(\"load\", this.handleLoad);\n  }\n  loadImage() {\n    // save to \"this\" to remove \"load\" handler on unmount\n    this.image = new window.Image();\n    this.image.src = this.props.src;\n    this.image.addEventListener(\"load\", this.handleLoad);\n  }\n  handleLoad = () => {\n    // after setState react-konva will update canvas and redraw the layer\n    // because \"image\" property is changed\n    this.setState({\n      image: this.image\n    });\n    // if you keep same image object during source updates\n    // you will have to update layer manually:\n    // this.imageNode.getLayer().batchDraw();\n  };\n  render() {\n    return (\n      <Image\n        key={this.props.key}\n        x={this.props.x}\n        y={this.props.y}\n        scaleX={this.props.scale}\n        scaleY={this.props.scale}\n        image={this.state.image}\n        width={100}\n        height={100}\n        ref={node => {\n          this.imageNode = node;\n        }}\n      />\n    );\n  }\n}\n\nexport default SvgRender;\n\n// import React, { Component } from 'react';\n// import { render } from 'react-dom';\n// import { Stage, Layer, Image } from 'react-konva';\n// import useImage from 'use-image';\n\n// // custom component that will handle loading image from url\n// // you may add more logic here to handle \"loading\" state\n// // or if loading is failed\n// // VERY IMPORTANT NOTES:\n// // at first we will set image state to null\n// // and then we will set it to native image instance when it is loaded\n// class URLImage extends React.Component {\n//   state = {\n//     image: null\n//   };\n//   componentDidMount() {\n//     this.loadImage();\n//   }\n//   componentDidUpdate(oldProps) {\n//     if (oldProps.src !== this.props.src) {\n//       this.loadImage();\n//     }\n//   }\n//   componentWillUnmount() {\n//     this.image.removeEventListener('load', this.handleLoad);\n//   }\n//   loadImage() {\n//     // save to \"this\" to remove \"load\" handler on unmount\n//     this.image = new window.Image();\n//     this.image.src = this.props.src;\n//     this.image.addEventListener('load', this.handleLoad);\n//   }\n//   handleLoad = () => {\n//     // after setState react-konva will update canvas and redraw the layer\n//     // because \"image\" property is changed\n//     this.setState({\n//       image: this.image\n//     });\n//     // if you keep same image object during source updates\n//     // you will have to update layer manually:\n//     // this.imageNode.getLayer().batchDraw();\n//   };\n//   render() {\n//     return (\n//       <Image\n//         x={this.props.x}\n//         y={this.props.y}\n//         image={this.state.image}\n//         ref={node => {\n//           this.imageNode = node;\n//         }}\n//       />\n//     );\n//   }\n// }\n","export const placement = (shapes, width, height) => {\n  return shapes.map(shape => {\n    return {\n      ...shape,\n      pos: { x: randomInRange(1, width), y: randomInRange(1, height) }\n    };\n  });\n};\nexport const placeInZone = cap => randomInRange(10, cap - 100);\n\nexport const randomInRange = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1) + min);\n\nexport const placementInter = (cap, otherBodys, count = 1) => {\n  let newPos = {\n    x: randomInRange(100, cap.innerWidth - 700),\n    y: randomInRange(100, cap.innerHeight - 100)\n  };\n\n  for (let i = 0; i < otherBodys.flat().length; i++) {\n    const pos = otherBodys.flat()[i];\n    if (\n      newPos.x > pos.pos.x &&\n      newPos.x < pos.pos.x + 120 &&\n      newPos.y > pos.pos.y &&\n      newPos.y < pos.pos.y + 120\n    ) {\n      console.log(\"I got fucked\");\n      if (count < 10) {\n        placementInter(cap, otherBodys, count + 1);\n      } else {\n        console.log(\"offset\");\n\n        newPos = {\n          x: -100,\n          y: -100\n        };\n      }\n    }\n  }\n  console.log(newPos.x);\n\n  return newPos;\n};\n","import React, { Component } from \"react\";\nimport Canvg from \"canvg\";\n// import logo from \"./logo.svg\";\n// import icon from \"../ic.svg\";\nimport Konva from \"konva\";\nimport { Stage, Layer, Image, Rect } from \"react-konva\";\nimport SvgRender from \"./svgRender\";\nimport {\n  placement,\n  placeInZone,\n  placementInter\n} from \"../helpers.js/placement\";\nclass Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { shapes: [], sideBar: 600 };\n    this.stageRef = React.createRef();\n  }\n  posAllShapes = () => {\n    this.savedRender = [];\n    this.setState(\n      {\n        shapes: placement(\n          this.props.shapes,\n          window.innerWidth,\n          window.innerHeight\n        )\n      },\n      () => {\n        // this.saveFile();\n        // this.saveImage();\n      }\n    );\n  };\n  savedRender = [];\n  textFile = null;\n\n  makeTextFile = text => {\n    var data = new Blob([text], { type: \"text/plain\" });\n\n    // If we are replacing a previously generated file we need to\n    // manually revoke the object URL to avoid memory leaks.\n    if (this.textFile !== null) {\n      window.URL.revokeObjectURL(this.textFile);\n    }\n\n    this.textFile = window.URL.createObjectURL(data);\n\n    // returns a URL you can use as a href\n    return this.textFile;\n  };\n\n  saveFile = () => {\n    // var create = document.getElementById(\"create\");\n    // create.addEventListener(\n    //   \"click\",\n    //   function() {\n    //     var link = document.createElement(\"a\");\n    //     link.setAttribute(\"download\", \"shapes.txt\");\n    //     link.href = this.makeTextFile(JSON.stringify(this.state.shapes));\n    //     document.body.appendChild(link);\n\n    //     // wait for the link to be added to the document\n    //     window.requestAnimationFrame(function() {\n    //       var event = new MouseEvent(\"click\");\n    //       link.dispatchEvent(event);\n    //       document.body.removeChild(link);\n    //     });\n    //   },\n    //   false\n    // );\n    this.downloadURI(\n      this.makeTextFile(JSON.stringify(this.savedRender)),\n      \"shapes.json\"\n    );\n  };\n  downloadURI = (uri, name) => {\n    var link = document.createElement(\"a\");\n    link.download = name;\n    link.href = uri;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n  saveImage = () => {\n    const dataURL = this.stageRef.current\n      .getStage()\n      .toDataURL({ pixelRatio: 3 });\n    this.downloadURI(dataURL, \"stage.png\");\n  };\n\n  renderArrayOfShapes = shape => {\n    let array = [];\n    let loopShape = [];\n    let count = 0;\n    while (array.length < shape.numToRender || count < 1000) {\n      let x = placeInZone(window.innerWidth - this.state.sideBar);\n      let y = placeInZone(window.innerHeight);\n      let noIn = true;\n      // let pos=placementInter( window,[...this.savedRender,...loopShape] )\n      let otherBodys = [...loopShape, ...this.savedRender];\n      for (let i = 0; i < otherBodys.flat().length; i++) {\n        const pos = otherBodys.flat()[i];\n        if (\n          pos.pos &&\n          x > pos.pos.x - 100 &&\n          x < pos.pos.x + 100 &&\n          y > pos.pos.y - 100 &&\n          y < pos.pos.y + 100\n        ) {\n          console.log(\"overlap\");\n          noIn = false;\n          count++;\n        }\n        // console.log(pos.pos, \"pos\");\n      }\n      if (noIn) {\n        array.push(\n          <SvgRender\n            key={y}\n            src={shape.image}\n            x={x}\n            y={y}\n            scale={shape.minSize}\n          />\n        );\n        loopShape.push({ ...shape, pos: { x, y } });\n      }\n    }\n    this.savedRender.push(loopShape);\n    return array;\n  };\n\n  shapeRender = () => {\n    const render = this.state.shapes.map(shape => {\n      return this.renderArrayOfShapes(shape);\n    });\n    // this.savedRender = render;\n    return render;\n  };\n\n  render() {\n    return (\n      <>\n        <Stage\n          ref={this.stageRef}\n          width={window.innerWidth - this.state.sideBar}\n          height={window.innerHeight}\n        >\n          <Layer>\n            <Rect\n              x={0}\n              y={0}\n              width={window.innerWidth - this.state.sideBar}\n              height={window.innerHeight}\n              fill=\"white\"\n            />\n          </Layer>\n          <Layer>\n            {this.shapeRender()}\n            {/* <SvgRender src={icon} x={300} y={800} scale={8} /> */}\n          </Layer>\n        </Stage>\n        <div style={{ display: \"flex\", flexDirection: \"column\" }}>\n          <button onClick={this.posAllShapes}>mix</button>\n          <button onClick={this.saveImage}>Save Image</button>\n          <button onClick={this.saveFile}>Save set</button>\n        </div>\n\n        <div id=\"create\"></div>\n      </>\n    );\n  }\n}\n\nexport default Canvas;\n","class shape {\n  constructor(image, imgName) {\n    this.image = image;\n    this.imageName = imgName;\n    this.pos = { x: 1, y: 1 };\n    this.color = \"#fffff\";\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.numToRender = 1;\n  }\n  toObj = () => {\n    return {\n      image: this.image,\n      pos: this.pos,\n      color: this.color,\n      minSize: this.minSize,\n      maxSize: this.maxSize\n    };\n  };\n  setPos = pos => {\n    this.pos = pos;\n  };\n  upDateNum = num => {\n    this.numToRender = Number(num);\n    return this;\n  };\n  upDateMinSize = num => {\n    this.minSize = Number(num);\n    return this;\n  };\n}\nexport default shape;\n","import React, { Component } from \"react\";\nimport Shape from \"../classes/shape\";\nclass UploadShape extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.fileRef = React.createRef();\n  }\n  makeShape = e => {\n    // console.log(shape, \"file\", e.target.files[0]);\n    const shape = new Shape(\n      URL.createObjectURL(e.target.files[0]),\n      e.target.files[0].name\n    );\n    console.log(shape, \"file\", e.target.files[0]);\n\n    this.props.addShape(shape);\n  };\n  render() {\n    return (\n      <div>\n        <input type=\"file\" name=\"\" id=\"\" onChange={e => this.makeShape(e)} />\n        <button onClick={this.makeShape}>go </button>\n      </div>\n    );\n  }\n}\n\nexport default UploadShape;\n","import React, { Component } from \"react\";\nimport shape from \"../classes/shape\";\nclass EditShape extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.amountToSpawnRef = React.createRef();\n    this.scaleRef = React.createRef();\n  }\n  onUpdateScale = () => {\n    this.props.updateShape(\n      this.props.shape.upDateMinSize(this.scaleRef.current.value)\n    );\n  };\n  onUpdateAmount = () => {\n    this.props.updateShape(\n      this.props.shape.upDateNum(this.amountToSpawnRef.current.value)\n    );\n  };\n  render() {\n    const { shape } = this.props;\n    return (\n      <div key={this.props.key}>\n        {/* {shape.color} */}\n        {/* {shape.image} */}\n        <label>\n          number to spawn:\n          <input\n            onChange={this.onUpdateAmount}\n            ref={this.amountToSpawnRef}\n            type=\"text\"\n            value={shape.numToRender}\n          />\n        </label>\n        <label>\n          scale:\n          <input\n            ref={this.scaleRef}\n            onChange={this.onUpdateScale}\n            type=\"text\"\n            value={shape.minSize}\n          />\n        </label>\n        <img src={shape.image} width={100} height={100} alt=\"\" />\n      </div>\n    );\n  }\n}\n\nexport default EditShape;\n","import React, { Component } from \"react\";\nclass Notes extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n  render() {\n    return (\n      <div>\n        <h5>some things are missing / not ready yet</h5>\n        <p>\n          color, random scale, overlap control's, phone support,\n          <br /> locked down to just svgs(you can upload any image you want\n          right now),\n          <br /> replay from saved files, some svgs are broken, exporting svg\n        </p>\n        <p>so I hope what is done is still fun for you </p>\n      </div>\n    );\n  }\n}\n\nexport default Notes;\n","import React, { Component } from \"react\";\nimport UploadShape from \"./uploadShape\";\nimport EditShape from \"./editShape\";\nimport Notes from \"./notes\";\nclass Shapes extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    return (\n      <div>\n        {this.props.shapes.map((shape, i) => (\n          <EditShape\n            updateShape={this.props.updateShape}\n            shape={shape}\n            key={i}\n          ></EditShape>\n        ))}\n        <UploadShape addShape={this.props.addShape}></UploadShape>\n        <Notes></Notes>\n      </div>\n    );\n  }\n}\n\nexport default Shapes;\n","import React, { Component } from \"react\";\nimport { Grid, box } from \"@material-ui/core\";\nimport Canvas from \"./canvas\";\nimport Shapes from \"./shapes\";\nclass Home extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      shapes: []\n    };\n  }\n  addShape = shape => {\n    const shapes = [shape, ...this.state.shapes];\n    this.setState({ shapes });\n  };\n  updateShape = shape => {\n    const shapes = this.state.shapes.map(s =>\n      s.image === shape.image ? shape : s\n    );\n    this.setState({ shapes });\n  };\n  render() {\n    return (\n      <div style={{ display: \"flex\" }}>\n        <div style={{ display: \"flex\" }}>\n          <Canvas shapes={this.state.shapes}></Canvas>\n        </div>\n        <div style={{ display: \"flex\" }}>\n          <Shapes\n            shapes={this.state.shapes}\n            addShape={this.addShape}\n            updateShape={this.updateShape}\n          ></Shapes>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","import React from \"react\";\n// import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Home from \"./componets/home\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Home></Home>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}