{"ast":null,"code":"import _objectSpread from \"/Users/coles/Documents/brett/react/shapes/app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nexport const placement = (shapes, width, height) => {\n  return shapes.map(shape => {\n    return _objectSpread({}, shape, {\n      pos: {\n        x: randomInRange(1, width),\n        y: randomInRange(1, height)\n      }\n    });\n  });\n};\nexport const placeInZone = (cap, shape) => {\n  const shapeWidth = 100 * shape.minSize;\n  return randomInRange(10, cap - shapeWidth);\n};\nexport const randomInRange = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\nexport const placementInter = (cap, otherBodys, count = 1) => {\n  let newPos = {\n    x: randomInRange(100, cap.innerWidth - 700),\n    y: randomInRange(100, cap.innerHeight - 100)\n  };\n\n  for (let i = 0; i < otherBodys.flat().length; i++) {\n    const pos = otherBodys.flat()[i];\n\n    if (newPos.x > pos.pos.x && newPos.x < pos.pos.x + 120 && newPos.y > pos.pos.y && newPos.y < pos.pos.y + 120) {\n      console.log(\"I got fucked\");\n\n      if (count < 10) {\n        placementInter(cap, otherBodys, count + 1);\n      } else {\n        console.log(\"offset\");\n        newPos = {\n          x: -100,\n          y: -100\n        };\n      }\n    }\n  }\n\n  console.log(newPos.x);\n  return newPos;\n};\nexport const checkOverLap = (y, x, pos, shape) => {\n  const shapeWidth = 100 * shape.minSize;\n  return x > pos.pos.x - shapeWidth && x < pos.pos.x + shapeWidth && y > pos.pos.y - shapeWidth && y < pos.pos.y + shapeWidth;\n};","map":{"version":3,"sources":["/Users/coles/Documents/brett/react/shapes/app/src/helpers.js/placement.js"],"names":["placement","shapes","width","height","map","shape","pos","x","randomInRange","y","placeInZone","cap","shapeWidth","minSize","min","max","Math","floor","random","placementInter","otherBodys","count","newPos","innerWidth","innerHeight","i","flat","length","console","log","checkOverLap"],"mappings":"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","sourcesContent":["export const placement = (shapes, width, height) => {\n  return shapes.map(shape => {\n    return {\n      ...shape,\n      pos: { x: randomInRange(1, width), y: randomInRange(1, height) }\n    };\n  });\n};\nexport const placeInZone = (cap, shape) => {\n  const shapeWidth = 100 * shape.minSize;\n  return randomInRange(10, cap - shapeWidth);\n};\n\nexport const randomInRange = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1) + min);\n\nexport const placementInter = (cap, otherBodys, count = 1) => {\n  let newPos = {\n    x: randomInRange(100, cap.innerWidth - 700),\n    y: randomInRange(100, cap.innerHeight - 100)\n  };\n\n  for (let i = 0; i < otherBodys.flat().length; i++) {\n    const pos = otherBodys.flat()[i];\n    if (\n      newPos.x > pos.pos.x &&\n      newPos.x < pos.pos.x + 120 &&\n      newPos.y > pos.pos.y &&\n      newPos.y < pos.pos.y + 120\n    ) {\n      console.log(\"I got fucked\");\n      if (count < 10) {\n        placementInter(cap, otherBodys, count + 1);\n      } else {\n        console.log(\"offset\");\n\n        newPos = {\n          x: -100,\n          y: -100\n        };\n      }\n    }\n  }\n  console.log(newPos.x);\n\n  return newPos;\n};\n\nexport const checkOverLap = (y, x, pos, shape) => {\n  const shapeWidth = 100 * shape.minSize;\n  return (\n    x > pos.pos.x - shapeWidth &&\n    x < pos.pos.x + shapeWidth &&\n    y > pos.pos.y - shapeWidth &&\n    y < pos.pos.y + shapeWidth\n  );\n};\n"]},"metadata":{},"sourceType":"module"}